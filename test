# Server Module
import io, base64
from PIL import Image, ImageOps
import anvil.server

# ── PODSTAW SWOJE IMPLEMENTACJE ───────────────────────────────
def decrypt_bytes(encrypted: bytes) -> bytes:
    # TODO: Twoja realna deszyfracja
    return encrypted

def encrypt_bytes(plain: bytes) -> bytes:
    # TODO: Twoja realna szyfracja
    return plain
# ──────────────────────────────────────────────────────────────

@anvil.server.callable
def get_single_image_from_api_compressed(
    file_name: str,
    max_side: int = 1600,
    quality: int = 60,
    use_webp: bool = True
):
    # 1) Pobierz zaszyfrowane base64 z Twojej funkcji (NIE ZMIENIAMY JEJ)
    encrypted_b64 = get_single_image_from_api(file_name)

    # 2) base64 -> bytes -> DECRYPT
    encrypted_bytes = base64.b64decode(encrypted_b64)
    original_bytes = decrypt_bytes(encrypted_bytes)

    # 3) Pillow: orientacja EXIF, konwersja, skalowanie
    im = Image.open(io.BytesIO(original_bytes))
    im = ImageOps.exif_transpose(im)

    if use_webp:
        # WebP: RGB/RGBA
        im = im.convert("RGBA" if "A" in im.getbands() else "RGB")
    else:
        # JPEG: zawsze RGB
        im = im.convert("RGB")

    im.thumbnail((max_side, max_side), Image.LANCZOS)

    # 4) Zapis skompresowany
    out = io.BytesIO()
    if use_webp:
        im.save(out, format="WEBP", quality=quality, method=6)
    else:
        im.save(out, format="JPEG",
                quality=quality, optimize=True, progressive=True, subsampling=2)

    compressed_bytes = out.getvalue()

    # 5) ENCRYPT -> base64 i ZWRÓĆ DOKŁADNIE TAK JAK U CIEBIE (SAMO base64)
    re_encrypted = encrypt_bytes(compressed_bytes)
    b64_out = base64.b64encode(re_encrypted).decode("ascii")
    return b64_out
