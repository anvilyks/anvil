const copy_project = JSON.parse(JSON.stringify(project));


function replaceBlobToCustomInProject(proj, map) {
  console.log("[5] üöÄ Running blob‚Üícustom replacement");

  function recurse(obj) {
    if (!obj || typeof obj !== 'object') return;

    if (Array.isArray(obj)) {
      for (const item of obj) recurse(item);
      return;
    }

    // Zamiana atrybutu src w attributes
    if (obj.attributes?.src && map[obj.attributes.src]) {
      console.log("[5] üîÅ Replacing attributes.src:", obj.attributes.src);
      obj.attributes.src = map[obj.attributes.src];
    }

    // Zamiana bezpo≈õredniego src
    if (obj.src && map[obj.src]) {
      console.log("[5] üîÅ Replacing direct comp.src:", obj.src);
      obj.src = map[obj.src];
    }

    // Rekurencyjne przeszukiwanie obiektu
    for (const key in obj) {
      recurse(obj[key]);
    }
  }

  for (const page of proj.pages || []) {
    recurse(page);
  }


const copy_project = JSON.parse(JSON.stringify(project));
replaceBlobToCustomInProject(copy_project, blobToCustomMap);





function logSrcAndTypeFromProject(project) {
  function recurse(obj, path = '') {
    if (!obj || typeof obj !== 'object') return;

    if (Array.isArray(obj)) {
      obj.forEach((item, i) => recurse(item, `${path}[${i}]`));
    } else {
      if (obj.attributes?.src) {
        console.log(`[${path}] attributes.src: ${obj.attributes.src}`);
      }
      if (obj.src) {
        console.log(`[${path}] src: ${obj.src}`);
      }
      if (obj.type) {
        console.log(`[${path}] type: ${obj.type}`);
      }

      for (const key in obj) {
        if (typeof obj[key] === 'object') {
          recurse(obj[key], `${path}.${key}`);
        }
      }
    }
  }

  console.log("üîç Scanning project for src/type:");
  recurse(project);
}



const nativeStringify = (0, eval)('JSON.stringify');
console.log('copy_project =', nativeStringify(copy_project, null, 2));
