Skip to content
Chat history

You said:
Uploaded image
mam w Anviul przekazywanie zaÅ‚Ä…cznikÃ³w image jako encrypted file. chce te zdjÄ™cia mocno kompresowac przed wysyÅ‚kÄ… jak to zrobiÄ‡? 
ChatGPT said:

Thought for 51s
Jasne â€” da siÄ™ to zrobiÄ‡ na dwa sposoby: po stronie przeglÄ…darki (zanim w ogÃ³le coÅ› wyÅ›lesz) albo po stronie serwera Anvil (zaraz po pobraniu/odszyfrowaniu pliku).
PoniewaÅ¼ chcesz â€mocnoâ€ kompresowaÄ‡ przed wysyÅ‚kÄ…, najkorzystniej jest zrobiÄ‡ to po stronie klienta na <canvas> i wysÅ‚aÄ‡ juÅ¼ przeskalowany, skompresowany obraz. JeÅ›li wolisz prostsze rozwiÄ…zanie bez JS, zostawiÅ‚em teÅ¼ wariant serwerowy (Pillow).

1) Klient (Anvil) â€“ kompresja w przeglÄ…darce
PoniÅ¼sza funkcja bierze data URL (u Ciebie tworzysz je jako "data:{mime};base64,{encrypted_file}"), rysuje obraz na canvasie, zmniejsza rozdzielczoÅ›Ä‡ i zapisuje jako WebP albo JPEG z podanÄ… jakoÅ›ciÄ…. Zwraca anvil.BlobMedia, ktÃ³ry moÅ¼esz zaszyfrowaÄ‡ i wysÅ‚aÄ‡.

# Client code (Form)
from anvil.js import window
import anvil
from anvil import BlobMedia
import base64

async def compress_data_url_to_media(data_url, max_side=1600, quality=0.6, mime="image/webp"):
  # 1) ZaÅ‚aduj obraz
  img = window.Image.new()
  img.src = data_url
  await img.decode()  # czeka aÅ¼ siÄ™ wczyta

  # 2) Wylicz nowy rozmiar (maksymalny bok = max_side)
  w, h = img.width, img.height
  scale = min(1, max_side / max(w, h))
  new_w, new_h = int(w * scale), int(h * scale)

  # 3) Canvas + rysowanie
  canvas = window.document.createElement("canvas")
  canvas.width = new_w
  canvas.height = new_h
  ctx = canvas.getContext("2d")
  ctx.drawImage(img, 0, 0, new_w, new_h)

  # 4) Eksport do skompresowanego blobu (WebP/JPEG)
  blob = await window.Promise.new(lambda resolve, reject:
      canvas.toBlob(resolve, mime, quality))

  # 5) Blob -> bytes -> BlobMedia
  array_buf = await blob.arrayBuffer()
  py_bytes = bytes(window.Uint8Array.new(array_buf))
  filename = "image." + ("webp" if mime.endswith("webp") else "jpg")
  return BlobMedia(mime, py_bytes, name=filename)
UÅ¼ycie w Twoim przebiegu:

async def appi_file_names():
  images = anvil.server.call('get_images_from_api')  # lista nazw
  results = {}

  for data in images:
    file_name = data.get("file_name")
    file_ending = file_name.split(".")[-1].lower()
    # Odbierz **niekompresowany** obraz (po odszyfrowaniu u Ciebie albo w API)
    data_url = anvil.server.call('get_single_image_data_url', file_name)  
    # data_url = "data:image/...;base64,....."

    # MOCNA kompresja do WebP (np. max 1600px, quality 0.5)
    media = await compress_data_url_to_media(
        data_url,
        max_side=1600,
        quality=0.5,
        mime="image/webp"    # ewentualnie "image/jpeg"
    )

    # (opcjonalnie) usuÅ„ EXIF â€“ juÅ¼ i tak nie bÄ™dzie, bo canvas go nie przenosi
    # Zaszyfruj media.get_bytes() po swojej stronie i wyÅ›lij
    enc_b64 = anvil.server.call('encrypt_and_b64', media.get_bytes())

    results[file_name] = {
      "base64": f"data:{media.content_type};base64,{enc_b64}",
      "type": media.content_type
    }

  return results
Dlaczego to dziaÅ‚a â€przed wysyÅ‚kÄ…â€: caÅ‚y ciÄ™Å¼ar (skalowanie + kompresja) dzieje siÄ™ w przeglÄ…darce, wiÄ™c na serwer leci juÅ¼ duÅ¼o mniejszy plik.

WskazÃ³wki dot. jakoÅ›ci/rozmiaru

Ustaw max_side na 1280â€“1920 (zaleÅ¼nie od potrzeb UI).

mime="image/webp" daje zwykle mniejsze pliki niÅ¼ JPEG.

quality 0.5â€“0.65 to mocna kompresja uÅ¼ytkowo â€OKâ€ dla miniatur/podglÄ…dÃ³w.

Canvas zdejmuje metadane (EXIF), co takÅ¼e zmniejsza rozmiar.

2) Serwer (Anvil) â€“ kompresja Pillow po pobraniu
JeÅ›li chcesz trzymaÄ‡ siÄ™ logiki serwerowej, skompresuj obraz zaraz po pobraniu (i przed ewentualnym szyfrowaniem/wysyÅ‚kÄ… dalej):

# Server Module (requires Pillow)
import io, base64, requests
from PIL import Image
import anvil.server

@anvil.server.callable
def get_single_image_data_url(file_name, max_side=1600, quality=60, use_webp=True):
    # 1) Pobierz oryginaÅ‚
    url = f"https://twoje.api/{file_name}"
    orig_bytes = requests.get(url, timeout=20).content

    # 2) Pillow: otwÃ³rz, konwertuj, przeskaluj
    im = Image.open(io.BytesIO(orig_bytes))
    im = im.convert("RGB")  # pewna Å›cieÅ¼ka do JPEG/WebP
    im.thumbnail((max_side, max_side), Image.LANCZOS)

    # 3) Zapisz skompresowane
    out = io.BytesIO()
    if use_webp:
        im.save(out, format="WEBP", quality=quality, method=6)
        mime = "image/webp"
    else:
        im.save(out, format="JPEG", quality=quality, optimize=True, progressive=True, subsampling=2)
        mime = "image/jpeg"

    compressed = out.getvalue()
    b64 = base64.b64encode(compressed).decode("ascii")
    return f"data:{mime};base64,{b64}"
Tipy do â€mocnejâ€ kompresji na serwerze:

Zawsze zmniejsz rozdzielczoÅ›Ä‡ (thumbnail/resize) â€“ to daje najwiÄ™kszy zysk.

Preferuj WebP (quality 50â€“70).

Dla JPEG ustaw optimize=True, progressive=True, subsampling=2.

UsuÅ„ metadane (konwersja do RGB + ponowny zapis juÅ¼ je usuwa).

Co wybraÄ‡?
Chcesz oszczÄ™dziÄ‡ upload (czas i transfer): wariant klientowy (canvas).

Wolisz prostotÄ™ i nie zaleÅ¼y Ci na transferze klient â†’ serwer: wariant serwerowy (Pillow).

JeÅ›li podasz, gdzie dokÅ‚adnie w Twoim flow nastÄ™puje szyfrowanie (przed/po data URL), mogÄ™ wstrzeliÄ‡ siÄ™ idealnie w TwÃ³j kod i dorzuciÄ‡ gotowe funkcje encrypt/decrypt na BlobMedia/bytes.

You said:
# Client code (Form)
from anvil.js import window
import anvil
from anvil import BlobMedia
import base64

async def compress_data_url_to_media(data_url, max_side=1600, quality=0.6, mime="image/webp"):
  # 1) ZaÅ‚aduj obraz
  img = window.Image.new()
  img.src = data_url
  await img.decode()  # czeka aÅ¼ siÄ™ wczyta

  # 2) Wylicz nowy rozmiar (maksymalny bok = max_side)
  w, h = img.width, img.height
  scale = min(1, max_side / max(w, h))
  new_w, new_h = int(w * scale), int(h * scale)

  # 3) Canvas + rysowanie
  canvas = window.document.createElement("canvas")
  canvas.width = new_w
  canvas.height = new_h
  ctx = canvas.getContext("2d")
  ctx.drawImage(img, 0, 0, new_w, new_h)

  # 4) Eksport do skompresowanego blobu (WebP/JPEG)
  blob = await window.Promise.new(lambda resolve, reject:
      canvas.toBlob(resolve, mime, quality))

  # 5) Blob -> bytes -> BlobMedia
  array_buf = await blob.arrayBuffer()
  py_bytes = bytes(window.Uint8Array.new(array_buf))
  filename = "image." + ("webp" if mime.endswith("webp") else "jpg")
  return BlobMedia(mime, py_bytes, name=filename)  czy moge te funkcjÄ™ daÄ‡ w util po stronie serwera?
ChatGPT said:
Nie â€” tej konkretnej funkcji nie moÅ¼esz przenieÅ›Ä‡ do util po stronie serwera,
bo ona korzysta z:

anvil.js â†’ dostÄ™pne tylko w kodzie klienta (uruchamianym w przeglÄ…darce).

window.Image, canvas â†’ to sÄ… obiekty DOM/HTML5, ktÃ³re istniejÄ… tylko w przeglÄ…darce.

Serwer Anvil nie ma przeglÄ…darki ani kontekstu JS/DOM, wiÄ™c te wywoÅ‚ania tam nie dziaÅ‚ajÄ….

JeÅ›li chcesz mieÄ‡ â€takÄ… samÄ…â€ funkcjÄ™ na serwerze, musiaÅ‚byÅ›:

napisaÄ‡ wersjÄ™ w Pythonie serwerowym z uÅ¼yciem biblioteki Pillow (PIL)
do otwierania obrazÃ³w, skalowania i zapisu do WebP/JPEG.

nie bÄ™dzie tam canvas, tylko Image.open(...), thumbnail(...) i save(...).

ğŸ’¡ MoÅ¼esz zrobiÄ‡ tak:

Wersja klientowa (canvas) â†’ kompresuje obraz przed wysyÅ‚kÄ… na serwer.

Wersja serwerowa (Pillow) â†’ kompresuje obraz, ktÃ³ry juÅ¼ jest na serwerze (np. pobrany z API).

Chcesz, Å¼ebym przygotowaÅ‚ Ci analogicznÄ… wersjÄ™ tej funkcji w Pythonie serwerowym z Pillow, Å¼eby dziaÅ‚aÅ‚a tak jak Twoja klientowa?






Nie wybrano plikuNie wybrano pliku
ChatGPT can make mistakes. Check important info. See Cookie Preferences.
